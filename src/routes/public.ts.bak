import { Router } from 'express'
import { body, validationResult } from 'express-validator'
import { publicRateLimiter } from '../middleware/rateLimiter'
import { PublicBookingService } from '../services/publicBookingService'

const router = Router()

// Apply rate limiting to public routes
router.use(publicRateLimiter)

// GET /api/public/:domain/services
router.get('/:domain/services', async (req, res, next) => {
  try {
    const { domain } = req.params
    const result = await PublicBookingService.getPublicServices(domain)
    res.json({
      success: true,
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// GET /api/public/:domain/availability
router.get('/:domain/availability', [
  body('serviceId').notEmpty(),
  body('date').isISO8601()
], async (req, res, next) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() })
    }

    const { domain } = req.params
    const { serviceId, date } = req.query

    const result = await PublicBookingService.getPublicAvailability(
      domain, 
      serviceId as string, 
      date as string
    )
    res.json({
      success: true,
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// POST /api/public/:domain/booking
router.post('/:domain/booking', [
  body('serviceId').notEmpty(),
  body('staffId').notEmpty(),
  body('clientName').trim().isLength({ min: 1 }),
  body('clientEmail').isEmail().normalizeEmail(),
  body('clientPhone').isMobilePhone(),
  body('startAt').isISO8601(),
  body('endAt').isISO8601(),
  body('paymentMethod').isIn(['stripe', 'swipe', 'cash']),
  body('depositPaidCents').optional().isInt({ min: 0 })
], async (req, res, next) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() })
    }

    const { domain } = req.params
    const result = await PublicBookingService.createPublicBooking(domain, req.body)
    
    res.status(201).json({
      success: true,
      message: 'Booking created successfully',
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// POST /api/public/:domain/hold
router.post('/:domain/hold', [
  body('serviceId').notEmpty(),
  body('clientName').trim().isLength({ min: 1 }),
  body('clientEmail').isEmail().normalizeEmail(),
  body('clientPhone').isMobilePhone(),
  body('startAt').isISO8601(),
  body('endAt').isISO8601()
], async (req, res, next) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() })
    }

    const { domain } = req.params
    const result = await PublicBookingService.createPublicHold(domain, req.body)
    
    res.status(201).json({
      success: true,
      message: 'Hold created successfully',
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// POST /api/public/:domain/waitlist
router.post('/:domain/waitlist', [
  body('serviceId').notEmpty(),
  body('clientName').trim().isLength({ min: 1 }),
  body('clientEmail').isEmail().normalizeEmail(),
  body('clientPhone').isMobilePhone(),
  body('preferredDate').isISO8601(),
  body('preferredTime').matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
  body('flexibleDays').optional().isInt({ min: 1, max: 30 }),
  body('autoAccept').optional().isBoolean()
], async (req, res, next) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() })
    }

    const { domain } = req.params
    const result = await PublicBookingService.addToPublicWaitlist(domain, req.body)
    
    res.status(201).json({
      success: true,
      message: 'Added to waitlist successfully',
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// GET /api/public/:domain/booking/:id
router.get('/:domain/booking/:id', async (req, res, next) => {
  try {
    const { domain, id } = req.params
    const result = await PublicBookingService.getPublicBooking(domain, id)
    res.json({
      success: true,
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// DELETE /api/public/:domain/booking/:id
router.delete('/:domain/booking/:id', [
  body('reason').optional().trim()
], async (req, res, next) => {
  try {
    const { domain, id } = req.params
    const { reason } = req.body
    const result = await PublicBookingService.cancelPublicBooking(domain, id, reason)
    res.json({
      success: true,
      message: 'Booking canceled successfully',
      data: result
    })
  } catch (error) {
    next(error)
  }
})

// GET /api/public/:domain/stats
router.get('/:domain/stats', async (req, res, next) => {
  try {
    const { domain } = req.params
    const { startDate, endDate } = req.query

    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' })
    }

    const result = await PublicBookingService.getPublicBookingStats(
      domain,
      new Date(startDate as string),
      new Date(endDate as string)
    )
    res.json({
      success: true,
      data: result
    })
  } catch (error) {
    next(error)
  }
})

export default router
